#!/usr/bin/env python3

import conf
import urllib.request
import os, sys, yaml, time, logging, socket, argparse
import daemon
from daemon import pidfile

from killer import GracefulKiller
from tgrm import TelegramSender

LOGGER_NAME = 'ip-monitor'

def request(url, logger=None):
    req = urllib.request.Request(
        url,
        data=None,
        headers={
            'User-Agent': 'curl/7.54.0'
        }
    )
    try:
        with urllib.request.urlopen(req, timeout=30) as url:
            return url.read().decode().strip()
    except urllib.error.URLError as ex:
        if logger: logger.warning("REQUEST: query URL is unreachable")
        return None
    except Exception as ex:
        if logger: logger.error("REQUEST: unknows error occured")
        return None

class Config(object):

    logger = None

    def __init__(self):
        self.__load_config()
        self.__logger().debug("cfg_file : {}".format(self.cfg_file))
        self.__logger().debug("pid_file : {}".format(self.pid_file))
        self.__logger().debug("log_file : {}".format(self.log_file))
        self.__logger().debug("log_level: {}".format(self.log_level))
        self.__logger().debug("hostname : {}".format(self.hostname))
        self.__logger().debug("timeout  : {}".format(self.timeout))
        self.__logger().debug("daemon   : {}".format(self.daemon))
        self.__logger().debug("token    : {}".format(self.tgrm_token))
        self.__logger().debug("chat     : {}".format(self.tgrm_chat))
        self.__logger().debug("url      : {}".format(self.url))

    # parse command line arguments
    def __load_config(self):
        parser = argparse.ArgumentParser(description="external IP monitor")
        parser.add_argument('-p', '--pid-file')
        parser.add_argument('-l', '--log-file')
        parser.add_argument('-c', '--cfg-file')
        parser.add_argument('-u', '--url',      default="http://ifconfig.me")
        parser.add_argument('-t', '--timeout',  default=10)
        parser.add_argument('-v', '--level',    default='DEBUG')
        parser.add_argument('-d', '--daemon',   default=False, action='store_true')
        parser.add_argument('-I', '--chat')
        parser.add_argument('-T', '--token')
        args = parser.parse_args()
        cfg = {}
        if args.cfg_file:
            try:
                cfg = self.__read_file(args.cfg_file)
            except Exception as ex:
                # self.__logger().error("__load_config: error reading configuration")
                self.__logger().error(ex)
                pass
        self.cfg_file   = args.cfg_file
        self.pid_file   = cfg.get('pid_file')       or args.pid_file
        self.log_file   = cfg.get('log_file')       or args.log_file
        self.log_level  = cfg.get('log_level')      or args.level
        self.timeout    = int(cfg.get('timeout')    or args.timeout)
        self.daemon     = cfg.get('daemon')         or args.daemon
        self.url        = cfg.get('url')            or args.url
        self.tgrm_chat  = cfg.get('telegram_chat')  or args.chat
        self.tgrm_token = cfg.get('telegram_token') or args.token
        self.hostname   = cfg.get('hostname')       or socket.gethostname()

    # reads configuration from YAML file
    def __read_file(self, file):
        # self.__logger().debug("__read_file: {}".format(os.path.dirname(os.path.realpath(__file__))))
        conf = {}
        try:
            with open(file) as fp:
                conf = yaml.load(fp)
        except Exception as ex:
            # self.__logger().error(ex)
            pass
        return conf

    # setup logger
    def __logger(self):
        if not self.logger:
            formatstr1 = '%(asctime)s - %(levelname)s - %(message)s'
            formatter1 = logging.Formatter(formatstr1, "%Y-%m-%d %H:%M:%S")

            formatstr2 = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            formatter2 = logging.Formatter(formatstr2, "%Y-%m-%d %H:%M:%S")

            logger = logging.getLogger(LOGGER_NAME)
            level  = logging.getLevelName(self.log_level)
            logger.setLevel(level)

            ch = logging.StreamHandler()
            ch.setLevel(level)
            ch.setFormatter(formatter1)
            logger.addHandler(ch)

            if self.log_file:
                fh = logging.FileHandler(self.log_file)
                fh.setLevel(level)
                fh.setFormatter(formatter2)
                logger.addHandler(fh)
                self.log_fh = fh

            self.logger = logger

        return self.logger

class App(object):

    external_ip = None

    def __init__(self, config):
        self.cfg = config
        self.tgrm = TelegramSender(token=self.cfg.tgrm_token,
                                   chat=self.cfg.tgrm_chat,
                                   logger=self.cfg.logger)
    def run(self):
        __killer = GracefulKiller(self.cfg.logger)
        self.cfg.logger.info("started")
        cnt = self.cfg.timeout
        while True:
            if __killer.kill_now:
                self.__shutdown()
                break;
            if cnt >= self.cfg.timeout:
                cnt = 0
                self.__action()
            time.sleep(1)
            cnt += 1
    def __shutdown(self):
        pass
    def __action(self):
        ip = request(self.cfg.url, self.cfg.logger)
        if ip != self.external_ip:
            self.cfg.logger.warning("ip change: {} -> {}".format(self.external_ip, ip))
            self.tgrm.send("<b>{}</b> ip change: {}".format(self.cfg.hostname, ip), b'\U000026A1')
            self.external_ip = ip
        self.cfg.logger.debug(".")

class Daemon(object):
    PID_FILE      = "/tmp/ext-ip-monitor.pid"

    def __init__(self, pidf):
        self.pidf   = pidf

    def start(self, app, files):
        self.app = app
        pidf     = self.pidf
        context = daemon.DaemonContext(
            working_directory='/tmp',
            umask=0o002,
            pidfile=pidfile.TimeoutPIDLockFile(pidf),
            )
        # context.signal_map = {
        #     signal.SIGINT:  __cleanup,
        #     signal.SIGTERM: __cleanup,
        #     signal.SIGHUP: 'terminate',
        #     # signal.SIGUSR1: __reload,
        # }
        context.files_preserve = files
        with context:
            app.run()

if __name__ == '__main__':
    cfg  = Config()
    app  = App(cfg)
    if cfg.daemon:
        Daemon(cfg.pid_file).start(app, [cfg.log_fh])
    else:
        app.run()
    logging.shutdown()
